---
title: "Matrix model selection package"
author: "Jonathan Walter, Thomas Anderson, Daniel Reuman"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Matrix model selection package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<!--Thoughts on what should maybe be included:
Brief qualitative intro to matrix model selection, with references
Reference to Jon's paper, and Tom's Oikos and L&O (hopefully) papers
I would ike to have an example using real data, Jon's gypsy moth or Tom's Oikos would be good, but need something where the 
  data (or a suitable subset) can be included, and it also needs to run reasonably fast
Basically we describe the method (copy from the section in supp mat in Ecol Lett, basically)
We also will have to intro the data
Mention the likelihood methods, cite the relevant papers, say the contexts where those wont work
Show the use of all the functions that the user needs on the data
Don't forget the new function matregtest
-->

# Brief introduction to matrix regression


# Example data


# Model selection on matrix models and the package functions
<!--This includes:
How to call the functions, how to interpret results - done on the example data, simultaneous description of how to use the functions and how   to interpret the stats
Brief statement on why the usual AIC methods wont work here
Brief statement on the likelihood methods that exist (REFS) and why they wont work here
-->

# Details of the method
<!--Much like the suppmat section of Jon's Ecol Lett paper that is about these methods -->

# Simulation study of effectiveness
<!-- Not sure what this will be or even if it will remain. Could be a paired down version of the model-based proof of effeciveness
of the method that is in Jon's Ecol Lett paper, or could be that whole thing reproduced (but watch run times) or could just be a 
summary of the results that appear there and a citation-->

The effectiveness of matrix model selection using leave-n-out cross-validation (mms) can be demonstrated
by applying mms to data generated by a theoretical model designed to simulate geographies of synchrony
arising from one or more mechanisms (Walter et al. 2017). Here, we describe the model and its implementation
for a test-case showing that mms can discriminate among a true predictor and multiple spurious predictors
representing mechanisms not operating in the model. A more comprehensive suite of tests of effectiveness are 
described in Walter et al. (2017).

<!--Paraphrase model description from EcoLetts paper-->
The model is an extension of a vector autoregressive moving-average (VARMA) model that generates time series of
abundance that may be correlated across multiple locations. The model simulates populations at locations $i$ = 1, ..., $P$,
with populations linked by dispersal and subject to spatially correlated environmental fluctuations (Moran Effects).
Fluctuations about the within-patch carrying capacity are denoted $w_{i}(t)$ for time $t$. The $\epsilon_{i}^{(j)}(t)$ are environmental 
conditions for potential Moran drivers. Dispersal is implemented via a $P$ by $P$ connectivity matrix, $D$. Population density 
dependence is controlled by the autoregressive coefficients $m_{il}$, while the influence of environmental variables is given by 
the moving average coefficients $q_{il}^{(j)}$. The model is:

<!--Slightly modified tex for eqn 5 from EcoLetts sup mat-->
\begin{equation}
\left(
\begin{array}{c}
w_1(t) \\
\vdots \\
w_P(t)
\end{array}
\right) \approx D
\left[
\left(
\begin{array}{c}
\sum_{l = 1}^{a}m_{ 1l}w_{ 1}(t  - l)+\sum_{j=1}^{b}\sum_{l=0}^{c}q_{1l}^{(j)}\epsilon_{1}^{(j)}(t-l) \\
\vdots \\
\sum_{l = 1}^{a}m_{ Pl}w_{ P}(t  - l)+\sum_{j=1}^{b}\sum_{l=0}^{c}q_{Pl}^{(j)}\epsilon_{P}^{(j)}(t-l) \\
\end{array}
\right)
\right],
\end{equation}

Here we consider a scenario in which spatial structure in population dynamics (i.e., geography of synchrony) arises from
spatial structure in an environmental driver (mechanism A in Walter et al. [2017]). We simulated population dynamics
in $P=16$ locations divided between two disjoint eight-location sets, $S_1$ and $S_2$. $S_1$ was {1,...,8} and $S_2$ was 
{9,...,16}. All locations had identical 2nd-order density dependence with $m_{i1} \approx 0.375$ and $m_{i2} \aprrox -0.368$. 
These parameters produce periodic oscillations with a dominant period length of $\approx$ 5 time steps. We simulated three environmetnal
drivers: an "operating" driver that strongly influences population dynamics (i.e., $q_{i1}^{(1)}=1$) and is spatially structured; a "latent" driver that is also spatially structured but does not influence population dynamics (i.e., $q_{i1}^{(2)}=0$); and a third driver 
representing local variability that is spatially unstructured (random) and has a small influence on population dynamics 
(i.e., $q_{i1}^{(2)}=0.1$). Spatial structure in environmental drivers was given by the covariance matrices $\Omega_{j}$, which were
block matrices having off-diagona entries $0.6$ within $S_1$ or $S_2$ and $0.3$ between groups. Organisms dispersed among populations
such that 5% of each population dispersed evenly among all other populations. The model was run for 150 time steps with a 100 time step burn-in period.

<!--Start example-->
We use simulated data to define a response matrix and multiple predictors, including a true predictor representing the operating mechanism
in the simulation described above, and two spurious predictors representing latent (non-operating) possible mechanisms. The data are
available using:

```{r}
library(mms)
#data(simdat)
#attach(simdat)
```

The object 'simdat' is a list containing four matrices. The first three are $P$ by $t$ matrices giving, respectively, abundances $w_{i}(t)$ and environmental fluctuations $\epsilon_{i}^{(j)}(t)$ for the operating ($j=1$) and latent ($j=2$) drivers. The fourth is the $P$ by $P$ dispersal matrix, $D$. We then compute synchrony matrices using Pearson correlations:

```{r}
#popsynch<-cor(t(simdat$pop), method="pearson")
#driversynch<-cor(t(simdat$driver), method="pearson")
#latentsynch<-cor(t(simdat$latent), method="pearson")
```

